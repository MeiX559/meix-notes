# JavaScript 事件

## 定时器机制

:::tip 前言
在看 `JavaScript 忍者秘籍`的时候，刚好看到计时器这一节，看完一遍之后感觉不是特别好理解，因此在这里对计时器机制进行详细的解析，一方面可以加深自身的理解，另一方面也希望能够帮助大家更好的阅读。
:::

在详细了解定时器机制之前，先看一下浏览器提供的两种创建计时器的方法以及清空计时器的方法：

| 方法          | 语法                      | 描述                                                                                 |
| ------------- | ------------------------- | ------------------------------------------------------------------------------------ |
| setTimeout    | id = setTimeout(fn,delay) | 启动一个计时器，在指定的延迟时间结束时执 行一次回调函数，返回标识计时器的唯一值      |
| clearTimeout  | clearTimeout(id)          | 当指定的计时器尚未触发时，取消（消除）计时器                                         |
| setInterval   | id = setTimeout(fn,delay) | 启动一个计时器，按照指定的延迟间隔不断执行回调函数，直至取消。返回标识计时器的唯一值 |
| clearInterval | clearInterval(id)         | 取消（消除）指定的计时器                                                             |

:::warning 注意点
定时器的时间间隔设为 0，也会有几毫秒的延迟。无法确保计时器延迟的时间。
:::

### 执行线程中的定时器

```jsx
setTimeout(function timeoutHandler() {
  /*Some timeout handle code that runs for 6ms*/
}, 10) //注册10ms后延迟执行函数

setInterval(function intervalHandler() {
  /*Some interval handle code that runs for 8ms*/
}, 10) //⇽--- 注册每10ms执行的周期函数

const myButton = document.getElementById('myButton')
myButton.addEventListener('click', function clickHandler() {
  /*Some click handle code that runs for 10ms*/
}) // ⇽--- 为按钮单击事件注册事件处理器

return <button id="myButton"></button>
```

上面这段代码中，注册了两个计时器（分别是延迟计时器和间隔计时器），延迟 10ms，接着又注册了一个单击事件处理器。假设延迟执行回调函数需要执行 6ms,间隔执行回调函数需要执行 8ms,单击事件处理器需要执行 10ms,因此上例中的代码需要运行 18ms。

假设用户在程序执行 6ms 的时候，快速单击按钮，队列中第一个任务是执行主线程 JavaScript 代码，我们上面已经知道，主线程代码大概执行 18ms，根据 JS 单线程特性，当线程正在执行状态的时候，有异步事件触发时会先排队，并且在线程空闲的时候才会开始执行。在主线程 JavaScript 代码执行的过程中：

1. 在 0ms 时，延迟计时器延迟 10ms 执行，间隔计时器间隔 10ms 执行，计时器的引用保存在浏览器中。
2. 在 6ms 时，单击鼠标，单击事件任务被添加到队列中。
3. 在 10ms 时，延迟计时器到期，间隔计时器的第一个时间间隔触发。

由于 JS 单线程特性，在主程序执行的时候，异步事件触发时会先排队。根据这个特性我们知道，在 6ms 时触发了单击事件，它被添加进队列中，在 10ms 的时候，延迟计时器和间隔计时器分别被添加进队列中排队等候线程空闲的时候执行。

此时队列中的排队顺序为：**单击事件处理器 -> 延迟计时器处理器 -> 间隔计时器处理器**

- 在 18ms 之后，主线程 JavaScript 代码执行完，此时宏任务队列中有三个任务正在等待被执行，根据先进先出的规则，此时单击事件处理器开始执行（假设需要耗时 10ms）。

`setInterval 的调用被废弃：`在单击事件处理程序执行的过程中，间隔计时器又会被触发一次，但是间隔计时器的实例已经在队列中等待被执行，因此该触发会被终止（因为浏览器不会同时创建两个相同的间隔计时器）。

单击事件在 28ms 执行完成，在第 28ms 时，事件循环进行下一次迭代，执行延迟计时器任务。

- 在 28ms 时，执行延迟计时器。假设延迟计时处理器需要执行 6ms，那么在 34ms 结束执行。
- 34ms 时，间隔计时处理器开始执行，此时距离添加到队列时相差 24ms。

执行过程图如下所示：
![执行过程图](./images/js-timer.png)

:::warning 注意点
计时器提供一种异步延迟执行代码片段的能力，至少要延迟指定的毫秒数，由于 JavaScript 单线程的本质，我们只能控制计时器何时被添加进队列中，无法控制计时器何时被执行。

正如上面的示例一样，我们指定了延迟计时器和间隔计时器都是延迟 10ms 执行，但是 js 是单线程的，主线程正在执行的时候，异步宏任务会被添加进队列中，等待线程空闲的时候才能开始执行，因此延迟计时器在 28ms 时才开始执行，间隔计时器在 34ms 才开始执行，与预期的执行时间有一定的差距。
:::

### 总结

- JS 是单线程的，事件执行需要根据先进先出原则排队执行。
- 定时器无法保证回调函数在指定的时间间隔内执行，我们只能控制计时器何时被添加进队列中，无法控制计时器何时能被执行。
- setInterval 的调用被废弃。
