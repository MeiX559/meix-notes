# 作用域浅析

::: tip 背景
几乎所有的编程语言最基本的功能之一就是能够储存变量中的值，并且能在之后对这个值进行访问或修改；事实上，正是这种储存和访问变量的值的能力将状态带给了程序；
但是将变量引入程序有几个需要讨论的问题：

1. 这些变量存储在哪里
2. 程序需要时如何找到它

以上的问题说明需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量，这套规则被称为作用域；
:::

## 作用域

### 编译原理

与传统编译语言相比，`JavaScript` 不是提前编译的，编译结果也不能在分布式系统中进行移植。

传统编译语言执行前编译的三个步骤：

1. 分词/词法分析：这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元；
   例如：var a = 2;这段程序通常会被分解成这些词法单元：var、a、=、2、；
   分词和词法分析之间的区别：主要差异在于词法单元的识别是通过有状态和无状态的方式进行的；
   分词和词法分析其实指的是同一件事，“词”在这里不是“word”，而是“token”——带有某种归类的字符串；这字符串叫做“词素”（lexeme）；
   “分词”这个动作是“tokenize”；“词”通过“词法”（lexical grammar）来界定，因而为了完成“分词”的目的，手段就是“词法分析”（lexical analysis）

2. 解析/语法分析：这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，这个树被称为“抽象语法树”（AST）；
   例如：var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration（变量声明） 的顶级节点，接下来是一个叫作 Identifier(标识符，它的值是 a)的子节点，以及一个叫作 AssignmentExpression（赋值表达式） 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(值，它的值是 2)的子节点。
3. 代码生成：将 AST 转换为可执行代码的过程被称为代码生成；抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在变量 a 中。

### 理解作用域

`引擎`：从头到尾负责整个 JavaScript 程序的编译以及执行过程；

`编译器`：引擎的好朋友，负责语法分析及代码生成等脏活累活；

`作用域`：引擎的另一位好朋友，负责收集并维护由所有声明的标识符——也就是变量，所组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。
以 var a = 2;这段代码为例，编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构；
遇到 var a 时，编译器会询问作用域是否有一个该名称的变量存在于同一个作用域的集合中，如果已经存在过，就会忽略该声明，否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a;

接下来，编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a=2 这个赋值操作；引擎运行时会询问作用域是否存在一个称为 a 的变量，如果存在，引擎就会使用这个变量，否则，引擎会继续查找该变量；如果引擎找到了 a 变量，就会将 2 赋值给它；否则引擎就会抛出一个异常；

总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（之前没有声明过），然后在运行时引擎会在作用域查找该变量，如果能找到就对它赋值；
